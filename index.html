<!DOCTYPE html>
<html lang="en" class="">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta name="description" content="Syberia provides an opinionated unified framework for fast iteration on classifier development and deployment. It is founded on convention over configuration and aims to solve the problems of classifier-specific data preparation and classifier-specific modeling parameters.">

    <title>Syberia</title>

    <link rel="stylesheet" media="all" href="stylesheets/rocco.css" />
    <link rel="stylesheet" media="all" href="stylesheets/github-markdown.css" />

    <script src="assets/highlight.pack.js"></script>
    <script type="text/javascript">
      hljs.initHighlightingOnLoad();
    </script>

    <style type="text/css">
      .header {
        position: fixed;
        top: 0px;
        width: 100%;
        background-color: rgba(0, 0, 0, 0.25);
        padding: 10px;
      }
      
      .header a {
        padding-right: 30px;
      }

      .container {
        margin-top: 40px;
      }

      body {
        padding: 0;
        margin: 0;
      }

      div.code-background {
        float: right;
        position: fixed;
        z-index: -1;
        height: 100%;
        background-color: #f8f8ff;
        width: 60%;
        right: 0px;
      }

      div.section {
        clear: both;
        margin: 0; padding: 0;
      }

      div.code {
        float: right;
        width: 60%;
      }

      code.R {
        font-size: 1.2em;
        line-height: 2em;
        margin-top: 0em;
        margin-bottom: -2em;
        padding-top: 0;
        margin-top: -1em;
      }

      code.R > span.spacer {
        position: relative;
      }

      div.code > pre {
        margin: 0;
        padding-left: 2em;
        margin-top: 0;
        margin-bottom: 0;
      }

      div.markdown {
        padding: 1em;
        padding-top: 0;
        background: #fff;
        float: left;
        width: 35%;
      }
    </style>

  </head>

  <body>
    <div class="header">
      <a href="https://github.com/robertzk/rocco">
        <img id="rocco-logo" src="https://img.shields.io/badge/Generated by rocco_v0.1.1-%E2%9C%93-blue.svg"/>
      </a>
    </div>
    <div class="container">

      <div class="code-background"></div>

        <div class="section">
          <div class="markdown markdown-body">
            <h1>director.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">if (getRversion() >= "2.15.1") {
  utils::globalVariables(c("input", "resource", "output", "resource_object"))
}

#' Fetch a syberia project director relative to a filename.
#'
#' @param filename character. Some in a syberia project.
#' @return the director object for the syberia project.
#' @export
#' @examples
#' \dontrun{
#'   # Pretend you have the file blah/foo.R in your syberia project ~/proj.
#'   syberia_projects('~/proj/blah/foo.R')
#'   # Now we have the director object for the ~/proj syberia project.
#' }
syberia_project <- local({
  # A cache of directors for the existent syberia projects
  syberia_projects <- list()

  function(filename = getwd()) {
    if (!(is.character(filename) && length(filename) == 1)) {
      stop("To fetch a syberia project, you must specify a file path ",
           "(a character vector of length 1). Instead we got a ",
           class(filename)[1], if (is.character(filename)) paste0(
           ' of length ', length(filename)))
    }
    # TODO: (RK) Don't go through syberia_root here

    root <- syberiaStructure::syberia_root(filename)
    if (is.null(root))
      stop("No syberia files detected in ", filename, "\n",
           "Try syberia_project('path') with a path that includes Syberia files or",
           "changing your working directory to a path with Syberia files.")
    else root <- normalizePath(root)
    if (!is.element(root, names(syberia_projects))) {
      syberia_projects[[root]] <<- bootstrap_syberia_project(director(root, 'syberia'))
    }
    syberia_projects[[root]]
  }
})

#' Bootstrap a syberia project by setting up its director object.
#'
#' The initial parsers that are derived from the syberia configuration
#' directory (\code{"config/"}) will be added to the director object here.
#' In particular, the \code{"config/routes.R"} file should specify the 
#' controllers for various resource types, which will reside in 
#' \code{"lib/controllers"} and be simple files with one function without
#' any arguments. This function will have the following present
#' when executed:
#'
#' \itemize{
#'   \item{"resource"}{The name of the resource (basically, the filename
#'     without the .R extension). If the resource is so-called an idempotent
#'     resource, then this will be the non-idempotent version. An
#'     idempotent resource is a file which is located in a directory whose
#'     name is the same as the filename without extension.
#'    
#'     For example, \code{"models/infection/infection.R"} is an idempotent resource
#'     because the \code{"infection.R"} file is present in the \code{"infection"}
#'     directory and--ignoring file extension--they are identical. This kind of
#'     convention allows any file in a syberia project to have helpers functions
#'     that better help you structure your files. For example, if
#'     \code{"infection.R"} needs to reference some long list of static
#'     variable names, they can can be placed in \code{"models/infection/const.R"}
#'     and included in \code{infection.R} using the \code{define} function
#'     from the Ramd package.
#'
#'     The \code{resource} key will be the filename without its extension if it
#'     is not an idempotent resource (so \code{"models/airtraffic.R"} will have
#'     key \code{"models/airtraffic"}). On the other hand, an idempotent
#'     resource will have key its residing directory so
#'     (\code{"models/pollution/pollution.R"} will have key
#'     \code{"models/pollution"}).}
#'
#'  \item{"input"}{When an R file is sourced through the \code{base::source}
#'     function, it leaves a trail we can follow. This is because \code{source}
#'     takes a second argument \code{local} (see the documentation for
#'     \code{base::source}) which allows you to provide an environment in which
#'     all execution of a given file will occur. Thus, if we have a file
#'     that has the body \code{test <- 1; string <- 'hello'}, using this trick
#'     we can construct an environment that has \code{test = 1} and
#'     \code{string = 'hello'}.
#'
#'     The \code{input} that is available to the controller is precisely
#'     this environment.}
#'
#'   \item{"output"}{When an R file is sourced through the \code{base::source}
#'     function, its last executed expression is available in the return
#'     value's \code{$value} key. Thus, if you had a file \code{"model.R"} with code
#'     \code{column <- 'Sepal.Length'; lm(iris$Sepal.Width ~ iris[[column]])}
#'     then we can access the \code{lm} model using \code{source('model.R')$value}.
#'     
#'     This "file return value" is precisely the \code{output} that is available
#'     to the controller for a resource.}
#'
#'   \item{"resource_body"}{The source code (as a string) of the resource is
#'     available as \code{resource_body} in the controller.}
#'
#'   \item{"director"}{The director object of the enclosing syberia project is
#'     available through the \code{director} local variable in controller.
#'
#'     For more information on this, see the \code{director} package.}
#'
#' }
#'
#' The \code{config/routes.R} file in your syberia project should look something
#' like this:
#'
#' \code{list('lib/classifiers' = 'classifier',
#'            'data'            = 'data')}
#'
#' where we have two kinds of resources: classifiers and data sources.
#' 
#' It is up to you how to define what these resources "do". The
#' \code{lib/classifiers} and \code{data} directories (in the root of your
#' syberia project) can have arbitrary code, and the \code{resource},
#' \code{input}, and \code{output} (like in the list above) are made available
#' to the controller.
#'
#' The return value of a controller will be the final result of a user
#' attempting to load a resource. For example, if we had the controller
#' \code{"lib/controllers/classifier.R"} with:
#'
#' \code{function() {
#'   classifier <- list(train = input$train, predict = input$predict)
#'   class(classifier) <- 'simpleClassifier'
#'   classifier
#' }}
#'
#' then we could define a classifier object like the one generated above
#' by placing a \code{train} and \code{predict} function in a file
#' \code{"simple.R"} in the \code{lib/classifiers} directory.
#'
#' Then, if we have our syberia project, say
#'    \code{proj <- syberia_project('some/directory')}
#' we could load this object with
#'    \code{simple_classifier <- proj$resource('lib/classifiers/simple')}
#' and have an object that we can call \code{simple_classifier$train(...)}
#' and \code{simple_classifier$predict} on.
#'
#' TODO: (RK) Explain why this is better than just random files.
#'
#' @param project director. The syberia director object to bootstrap.
bootstrap_syberia_project <- function(project) {
  register_config(project)
  register_controllers(project)
  register_routes(project)
  register_tests(project)
  custom_bootstrap(project)
  project$cache_set("boostrapped", TRUE)
  project
}

#' Run custom bootstrapping and startup actions.
#'
#' When a syberia project is first loaded, it is "bootstrapped" by performing
#' several startup procedures: registering the config/application file, 
#' registering the controllers, registering the routes, and setting up
#' the tests so that \code{test_project} works correctly. The user
#' can specify additional actions to perform using \code{custom_bootstrap}
#' if and only if a config/boot resource is present (i.e., either a
#' config/boot.R file or config/boot/boot.R file).
#'
#' Note that due to the dynamic and interactive nature of R, bootstrapping
#' can occur non-deterministically. Unlike, for example, a Ruby on Rails application,
#' which has one entrance point, a syberia project will be bootstrapped
#' whenever it is referenced from R code the first time. This includes when
#' any resources are loaded, tests are ran, configuration is accessed, etc.
#' You should think of the bootstrapping process as "lazy loading" all that
#' a syberia project needs to get to work.
#'
#' @inheritParams bootstrap_syberia_project
custom_bootstrap <- function(project) {
  if (project$exists('config/boot')) project$resource('config/boot')
}


#' Register configuration when bootstrapping a syberia project.
#'
#' @param project director. The syberia director object to bootstrap.
register_config <- function(project) {
  application_config_path <- file.path('config', 'application')
  if (!project$exists(application_config_path)) {
    stop("You must have a config/application.R file in your syberia project ",
         "at directory ", sQuote(project$root()), ".", .call = FALSE)
  }

  project$register_parser(application_config_path,
                          function() as.list(input), overwrite = TRUE)
  project$register_parser(file.path('config', 'environments'),
                          function() as.list(input), overwrite = TRUE)
}

#' Register routes when bootstrapping a syberia project.
#'
#' @param project director. The syberia director object to bootstrap.
register_routes <- function(project) {
  routes_path <- file.path('config', 'routes')
  if (project$exists(routes_path)) {
    project$register_parser(routes_path, routes_parser, overwrite = TRUE)
    project$resource('config/routes')
  }
}

#' Register parser for controllers.
#'
#' The only non-trivial action is to look for a \code{preprocessors} local
#' variable in the \code{input} provider to the parser. The parsed value
#' of a controller will be a list containing a \code{preprocessor} and
#' a \code{parser}
#'
#' @param project director. The syberia director object on which to register
#'   the default controllers parser.
register_controllers <- function(project) {
  controllers_path <- file.path('lib', 'controllers')
  project$register_parser(controllers_path, function() {
    if (exists('preprocessor', envir = input, inherits = FALSE) &&
        !is.function(input$preprocessor))
      stop("The preprocessor defined in ",
           sQuote(crayon::red(resource)),
           " must be a function, but instead is of class ",
           sQuote(class(input$preprocessor[1])), call. = FALSE)
    list(parser = output, preprocessor = input$preprocessor,
         cache = isTRUE(input$cache), test = !identical(FALSE, input$test))
  })
}

#' Register the default controller for Syberia project tests.
#'
#' By default, tests in a Syberia project will have access to the resource
#' they are testing as well the \code{testthatsomemore} package.
#' This function is responsible for bootstrapping this behavior in a
#' Syberia project. See the documentation for \code{test_project}
#' to understand how to create setup and teardown hooks (code that will be
#' run before all tests are executed).
#'
#' @param project director. The syberia director object on which to register
#'   the tests controller.
#' @seealso \code{\link{test_project}}
register_tests <- function(project) {
  project$register_preprocessor('config/environments/test', default_tests_environment_preprocessor, overwrite = TRUE)
  project$register_preprocessor('test', default_tests_preprocessor, overwrite = TRUE)
}

#' A director parser for parsing a routes file.
#'
#' A routes file (in \code{"config/routes.r"} relative to the syberia project)
#' should contain a list whose names give the route prefixes and whose
#' values are the controller names for parsing resources that begin with
#' these prefixes. For example, if the file contains
#' 
#' \code{list('models' = 'models', 'lib/adapters' = 'adapters')}
#'
#' then files in the directory \code{"models"} (relative to the root of the
#' syberia project) will be processed by the \code{"models"} controller
#' and the files in the directory \code{"lib/adapters"} will be
#' processed by the \code{adapters} controller. There should be files
#' \code{"adapters.R"} and \code{"models.R"} in the \code{"lib/controllers"}
#' directory containing only a single function. The function (the heart of
#' the controller) will be applied to files sourced in the respective
#' resource directory (\code{"models"} or \code{"lib/adapters"}).
#' See the function \code{bootstrap_syberia_project} to understand what
#' things are available in a controller function.
#'
#' @seealso \code{bootstrap_syberia_project}. 
routes_parser <- function() {
  error <- function(...) {
    stop("In your ", crayon::red("config/routes.R"), " file in the ",
         "syberia project at ", sQuote(crayon::blue(director$.root)),
         ' ', ..., call. = FALSE)
  }

  if (!is.list(output)) {
    error("you should return a list (put it at the end of the file). ",
         "Currently, you have something of type ", sQuote(class(output)[1]), ".")
    # TODO: (RK) More informative message here.
  }
  if (length(output) > 0 &&
      (any(sapply(names(output), function(n) !isTRUE(nzchar(n)))) ||
       length(unique(names(output))) != length(output))) {
    error(" your list of routes needs to have unique prefixes.")
    # TODO: (RK) Provide better information about name duplication or missing names.
  }

  # Only parse the routes file if it has changed, or the project has not
  # been bootstrapped.
  if (director$resource(resource, modification_tracker.touch = FALSE,
                        dependency_tracker.return = "any_dependencies_modified") ||
      !isTRUE(director$cache_get("bootstrapped"))) {
    lapply(names(output), function(route) {
      controller <- output[[route]]
      if (!is.character(controller) && !is.function(controller)) {
        error("Every route must be a character or a function (your route ",
              crayon::yellow(sQuote(route)), " is of type ",
              sQuote(class(controller)[1]), ")")
      }

      if (is.character(controller)) {
        routes <- director$cache_get("routes") %||% list()
        new_route <- routes[[route]]
        new_route <- c(new_route, controller)
        routes[[route]] <- new_route
        director$cache_set("routes", routes)

        controller <- director$resource(file.path('lib', 'controllers', controller))
      } else if (is.function(controller)) controller <- list(parser = controller)

      director$register_parser(route, controller$parser, cache = isTRUE(controller$cache))
      if (is.function(controller$preprocessor))
        director$register_preprocessor(route, controller$preprocessor)
      # TODO: (RK) More validations on routes?
    })
  }
  TRUE
}

#' The default preprocessor for syberia tests.
#'
#' @param resource_object directorResource
#' @param director director
#' @param source_args list
#' @param source function
default_tests_preprocessor <- function(resource_object, director, source_args, source) {
  tested_resource <- gsub("^test\\/", "", resource)
  if (!director$exists(tested_resource)) {
    # TODO: (RK) Figure out how this interacts with virtual resources.
    #warning("You are testing ", sQuote(crayon::yellow(tested_resource)),
    #        " but it does not exist in the project.\n", call. = FALSE, immediate = TRUE)
    #return(NULL)
  }

  context(tested_resource)
  make_tested_resource <- function(...) director$resource(tested_resource, ...)
  source_env$resource <- function() make_tested_resource(recompile. = TRUE)
  source()
}

#' The default preprocessor for syberia test environments.
#'
#' @param director director
#' @param source_args list
#' @param source function
default_tests_environment_preprocessor <- function(director, source_args, source) {
  # Provide access to the director for people with hardcore test setup
  # and teardown hooks.
  source_env$director <- director 
  source()
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>engine.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Bootstrap a Syberia engine.
#'
#' A Syberia engine defines the core re-usable structural unit across
#' different Syberia projects. In the same way that
#' \href{http://guides.rubyonrails.org/engines.html}{Rails engines}
#' provide a modular structure for \href{Rails}{http://rubyonrails.org/}
#' projects, Syberia engines serve as the re-usable rockbed upon which
#' to construct projects that contain similar components.
#'
#' A Syberia engine is managed by a \code{\link[director]{director}} object.
#' This object ensures that the engine cannot access resources outside of
#' its domain, and allows insularity from other engines and the top-level
#' project from which the engine will be used.
#'
#' @param filepath character. The root directory of the engine.
#'    If this directory does not define a (relative) \code{"config/application.R"} 
#'    file, the parent directories of \code{filepath} will be traversed
#'    until such a file is found, or the function will error.
#' @param ... Additional arguments used internally.
#' @export
#' @note The syberia package will maintain an internal cache of engines.
#'    Therefore, calling \code{syberia_engine} twice will retrieve the
#'    cached object. This cache is maintained in the \code{.syberia_env}
#'    environment object in the syberia package namespace.
#' @return The \code{\link[director]{director}} object responsible for
#'    managing the engine.
syberia_engine <- function(filepath, ...) {
  UseMethod("syberia_engine")
}

#' @export
syberia_engine.pre_engine <- function(filepath, ...) {
  build_engine(filepath)
}

#' @export
syberia_engine.character <- function(filepath, cache = TRUE) {
  traverse_parent_directories(normalizePath(filepath), function(filepath) {
    if (isTRUE(cache) && has_application_file(filepath)) {
      .syberia_env[[filepath]] <- .syberia_env[[filepath]] %||% build_engine(filepath)
    } else {
      build_engine(filepath)
    }
  }, error = sprintf("No syberia engine found at %s", sQuote(crayon::red(filepath))))
}

extensions <- c('.R', '.r', '/application.R', '/application.r')
has_application_file <- function(filepath) {
  any(file.exists(paste0(file.path(filepath, 'config', 'application'), extensions)))
}

#' @export
build_engine <- function(buildable) {
  UseMethod("build_engine")
}

#' @export
build_engine.pre_engine <- function(buildable) {
  dir <- engine_dir(buildable$prefix)
  if (!file.exists(dir)) buildable$builder(dir)
  syberia_engine(dir, cache = FALSE)
}

#' @export
build_engine.character <- function(buildable) {
  # bootstrap_engine(director::director(buildable))
  bootstrap_engine(syberia_engine_class$new(buildable))
}

engine_dir <- function(dir) {
  file.path(engine_location(), dir)
}

engine_location <- function() {
  path <- engine_location_path()
  if (!file.exists(path)) {
    if (!dir.create(path, FALSE, TRUE)) {
      stop(sprintf(paste0("Syberia needs a directory in which to place the code for ",
           "dependencies. Please ensure %s is writable, or set a ",
           "different path in the %s environment variable or ",
           "the %s global option (using %s)."),
           sQuote(crayon::red(path)),
           sQuote(crayon::yellow("SYBERIA_ENGINE_LOCATION")),
           sQuote(crayon::yellow("syberia.engine_location")),
           sQuote(crayon::magenta("options(syberia.engine_location = 'some/dir')"))))
    }
  }
  path
}

engine_location_path <- function() {
  Sys.getenv("SYBERIA_ENGINE_LOCATION") %|||%
  getOption("syberia.engine_location", "~/.R/.syberia/engines")
}

bootstrap_engine <- function(engine) {
  if (isTRUE(engine$cache_get("bootstrapped"))) return(engine)
  engine$register_preprocessor('config/boot',    boot_preprocessor)
  engine$register_preprocessor('config/engines', engine_preprocessor)
  engine$register_parser      ('config/engines', engine_parser)
  if (engine$exists("config/engines")) engine$resource("config/engines")
  if (engine$exists("config/boot"))    engine$resource("config/boot")
  engine$cache_set("bootstrapped", TRUE)
  engine
}

boot_preprocessor <- function(source, source_env, director) {
  source_env$director <- director
  source()
}

engine_preprocessor <- function(source, source_env, preprocessor_output) {
  preprocessor_output$engines <- new.env(parent = emptyenv())
  source_env$engine <- function(name, ...) {
    preprocessor_output$engines[[name]] <- list(...)
  }
  source()
}

engine_parser <- function(director, preprocessor_output) {
  if (isTRUE(director$cache_get("bootstrapped"))) return()

  for (engine in ls(preprocessor_output$engines, all = TRUE)) {
    register_engine(director, engine, parse_engine(preprocessor_output$engines[[engine]]),
                    mount = isTRUE(preprocessor_output$engines[[engine]]$mount))
  }

  if (exists(".onAttach", envir = input, inherits = FALSE)) {
    onAttach <- input$.onAttach
    environment(onAttach) <- list2env(
      list(director = director),
      parent = environment(onAttach)
    )
    director$cache_set(".onAttach", onAttach)
  }
  NULL
}

register_engine <- function(director, name, engine, mount = FALSE) {
  # TODO: (RK) Replace with $engines private member after R6ing.
  if (!director$cache_exists("engines")) {
    director$cache_set("engines", new.env(parent = emptyenv()))
  }
  env <- director$cache_get("engines")
  env[[name]] <- engine

  director$register_engine(name, engine, mount = mount)

  if (engine$cache_exists(".onAttach")) {
    engine$cache_get(".onAttach")(director)
  }

}

parse_engine <- function(engine_parameters) {
  engine_parameters$type <- engine_parameters$type %||% "github"

  if (!is.simple_string(engine_parameters$type)) {
    stop(sprintf("When defining an engine, please provide a string for the %s",
                 sQuote("type")), call. = FALSE)
  }

  parser <- paste0("parse_engine.", engine_parameters$type)
  if (!exists(parser, envir = getNamespace("syberia"), inherits = FALSE)) {
    stop(sprintf("Cannot load an engine of type %s", 
                 sQuote(crayon::red(engine_parameters$type))))
  }
  syberia_engine(get(parser, envir = getNamespace("syberia"))(engine_parameters),
                 cache = FALSE)
}

parse_engine.github <- function(engine_parameters) {
  repo    <- engine_parameters$repo %||% engine_parameters$repository
  version <- engine_parameters$version %||% "master"
  stopifnot(is.simple_string(repo))

  pre_engine(prefix = file.path("github", repo, version),
    builder = function(filepath) {
      status <- system2("git", c("clone", sprintf("git@github.com:%s", repo), filepath))
      stopifnot(status == 0)
    })
}

parse_engine.local <- function(engine_parameters) {
  path <- engine_parameters$path %||% stop("Please provide an engine path")
  if (!file.exists(path)) stop("The path ", sQuote(path), " does not exist.")
  path
}

pre_engine <- function(prefix, builder) {
  structure(list(prefix = prefix, builder = builder), class = "pre_engine")
}
#
#syberia_engine_instance <- function(director) {
#  structure(list(director = director), class = "syberia_engine")
#}
#

#`$.syberia_engine` <- function(engine, method) {
#  if (identical(method, "exists")) syberia_engine_exists(engine)
#  else if (identical(method, "resource")) syberia_engine_resource(engine)
#  else eval.parent(bquote(`$`(.(substitute(engine))[['director']], .(method))))
#}
#
#syberia_engine_exists <- function(engine) {
#  force(engine)
#  function(...) {
#    if (!engine[['director']]$exists(...)) {
#      for (subengine in ls(engine[['director']]$cache_get("engines"), all = TRUE)) {
#        if (engine[['director']]$cache_get("engines")[[subengine]]$exists(...)) {
#          return(TRUE)
#        }
#      }
#    }
#    FALSE
#  }
#}
#
#syberia_engine_resource <- function(engine) {
#  force(engine)
#  function(name, ...) {
#    if (!engine[['director']]$exists(name)) {
#      for (subengine in ls(engine[['director']]$cache_get("engines"), all = TRUE)) {
#        subdirector <- engine[['director']]$cache_get("engines")[[subengine]]
#        if (subdirector$exists(name)) {
#          return(subdirector$resource(name, ...))
#        }
#      }
#    }
#    engine$resource(name, ...)
#  }
#}
#
#print.syberia_engine <- function(x, ...) {
#  print(x$director)
#}

#' Whether to exclude a syberia engine from being used for resourcing.
#'
#' @param condition logical. Some condition.
#' @param engine syberia_engine. Engine object.
#' @export
should_exclude <- function(condition, engine) {
  UseMethod("should_exclude")
}

#' @export
should_exclude.syberia_engine <- function(...) { identical(...) }

#' @export
should_exclude.character <- function(condition, engine) {
  identical(condition, engine$root())
}

syberia_engine_class <- R6::R6Class("syberia_engine",
  portable = TRUE,
  inherit = director:::director_, #environment(director::director)$director_,
  public = list(
    .parent  = NULL,
    .engines = list(),
    .set_parent = function(parent) { self$.parent <<- parent },

    register_engine = function(name, engine, mount = FALSE) {
      stopifnot(is(engine, "syberia_engine"))
      self$.engines[[name]] <<- list(engine = engine, mount = isTRUE(mount))
      if (isTRUE(mount)) engine$.set_parent(self)
    },

    resource = function(name, ..., parent. = TRUE, children. = TRUE, exclude. = NULL, defining_environment. = parent.frame()) {</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Check the parent engines for resource existence.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">      if (isTRUE(parent.) && !is.null(self$.parent)) {
        if (self$.parent$exists(name, parent. = TRUE, children. = TRUE, exclude. = list(self$root()))) {
          return(self$.parent$resource(name, ..., defining_environment. = defining_environment.))
        }
      }
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Check the current engines for resource existence.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">      if (super$exists(name)) return(super$resource(name, ..., defining_environment. = defining_environment.))
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Check the subengines for resource existence.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">      if (isTRUE(children.)) {
        for (engine in self$.engines) {
          if (isTRUE(engine$mount)) {
            engine <- engine$engine
            if (!any(vapply(exclude., should_exclude, logical(1), engine))) {
              if (engine$exists(name, parent. = FALSE, children. = TRUE, exclude. = exclude.)) {
                return(engine$resource(name, ..., defining_environment. = defining_environment.))
              }
            }
          }
        }
      }
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Force trigger an error using the self director.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">      super$resource(name, ..., defining_environment. = defining_environment.)
    },

    exists = function(resource, ..., parent. = TRUE, children. = TRUE, exclude. = NULL) {</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Check the parent engines for resource existence.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">      if (isTRUE(parent.) && !is.null(self$.parent)) {
        if (self$.parent$exists(resource, ..., parent. = TRUE, children. = TRUE, exclude. = list(self$root()))) {
          return(TRUE)
        }
      }
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Check the current engines for resource existence.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">      if (super$exists(resource, ...)) return(TRUE)
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Check the subengines for resource existence.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">      if (isTRUE(children.)) {
        for (engine in self$.engines) {
          if (isTRUE(engine$mount)) {
            engine <- engine$engine
            if (!any(vapply(exclude., should_exclude, logical(1), engine))) {
              if (engine$exists(resource, ..., parent. = FALSE, children. = TRUE, exclude. = exclude.)) {
                return(TRUE)
              }
            }
          }
        }
      }

      FALSE
    }
  ),
  private = list(
  )
)
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>syberia-package.r</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Syberia provides an opinionated unified framework for
#' fast iteration on classifier development and deployment. It is
#' founded on convention over configuration and aims to solve the
#' problems of classifier-specific data preparation and
#' classifier-specific modeling parameters.
#'
#' @name syberia
#' @docType package
#' @import testthat Ramd stagerunner statsUtils mungebits tundra syberiaMungebits syberiaStructure syberiaStages director objectdiff R6
NULL
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>An environment used for caching some syberia-managed objects, like directors.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">.syberia_env <- new.env(parent = emptyenv())</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>tests.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Run all tests in a syberia project.
#'
#' The tests that will be run are all those in the \code{test} subdirectory
#' of the root of the syberia project.
#'
#' By default, no test setup or teardown occurs. That is, there is no code that
#' is executed before all tests run and after all tests run. However, there do
#' exist hooks to provide this behavior. This can also be used to perform
#' additional testing not covered by sourcing all files in the "test/" directory
#' of the syberia project.
#'
#' To provide a setup or teardown hook, simply place a function or list of
#' functions in a local variable \code{setup} or \code{teardown}, respectively,
#' in \code{config/environments/test} relative to the root of the syberia project.
#'
#' For example, creating a file \code{config/environments/test.R} with the code
#' code \code{setup <- function(env) cat("Running all tests.")} will print a message
#' before all the tests are run. The one parameter the function must take is an
#' environment which will contain a single key, `director`, pointing to the 
#' `director` object coming from `syberia_project`.
#'
#' @param project director or character. The director for the syberia project.
#'    If a \code{character}, it will be passed to \code{syberia_project} first.
#' @param base character. Any subdirectory to test specifically. By default,
#'    the empty string \code{''} which means "test everything".
#' @seealso \code{\link{syberia_project}}
#' @export
#' @return \code{TRUE} if all tests pass or will error otherwise. Note this
#'    function uses \code{pblapply} from the \code{pbapply} package to
#'    represent progress.
test_project <- function(project = syberia_project(), base = '') {
  if (is.character(project)) project <- syberia_project(project)
  test_path <- file.path(project$root(), 'test')
  tests <- project$find(base = gsub("\\/$", "", file.path('test', base)))

  ignored_tests <- file.path('test', test_environment_config(project)$ignored_tests %||% character(0))
  all_tests <- tests
  tests <- Filter(function(x) !director:::any_is_substring_of(x, ignored_tests), tests)
  ignored_test_paths <- setdiff(all_tests, tests)

  ensure_resources_have_tests(project, tests, ignore = ignored_test_paths)

  # TODO: (RK) Figure out how to run this in an environment that has testthat
  # without attaching to the global environment.
  load_test_packages()
  
  ensure_no_global_variable_pollution(check_options = TRUE, {
    test_hook(project, type = 'setup')$run() # Run the test setup hook stageRunner

    # Run all tests
    # TODO: (RK) Don't rely on pblapply
    old_pboptions <- options('pboptions')
    on.exit(options(old_pboptions))
    single_setup <- test_hook(project, type = 'single_setup')
    single_teardown <- test_hook(project, type = 'single_teardown')
    requireNamespace("pbapply")
    apply_function <- if ("pbapply" %in% installed.packages()[,1]) pbapply::pblapply else lapply
    apply_function(tests, function(t) {
      ensure_no_global_variable_pollution(check_options = TRUE, {
        single_setup$.context$resource <- t
        single_setup$run()
        suppressMessages(project$resource(t, recompile = TRUE, recompile. = TRUE))
        single_teardown$.context$resource <- t
        single_teardown$run()
      }, desc = paste('running', t))
    })

    # TODO: (RK) Populate teardown stageRunner environment with test info?
    # Could be useful to some people.
    test_hook(project, type = 'teardown')$run() # Run the test teardown hook stageRunner
  }, desc = "running this project's tests (this is bad and should never happen)")

  invisible(TRUE)
}

load_test_packages <- function() {
  Ramd::packages('testthat')
  if (!is.element('testthatsomemore', installed.packages()[,1])) {
    install.packages('robertzk/testthatsomemore')
  }
}

#' Check that all mandatory tested resources have tests.
#'
#' @param project director or character. The director for the syberia project.
#' @param tests character. The tests to check. By default, all tests in the project.
#' @param ignore character. A vector of tests to ignore (and not check for presence).
ensure_resources_have_tests <- function(project, tests = project$find(base = 'test'), ignore = character(0)) {
  controllers <- project$find('lib/controllers/')

  # Do not consider test controllers -- no meta-tests, heh!
  controllers <- controllers[!grepl('^\\/lib/controllers/test/', controllers)]

  # Filter down to the controllers that have make tests mandatory
  # (the ones that aren't will have test <- FALSE)
  controllers <- setNames(
    lapply(controllers, function(x) project$resource(x)),
    controllers)
  controllers <- names(Filter(function(controller) controller$test, controllers))

  # Remove the lib/controllers prefix
  controllers <- gsub("\\/?lib\\/controllers/", "", controllers)

  # Get the routes that match controllers which we are testing.
  routes <- names(Filter(
    function(route_controller) is.element(route_controller, controllers),
    project$cache_get("routes")
  ))

  # Filter down to the resources that contain one of the routes as a substring
  # (and thus are owned by a controller which makes testing mandatory).
  resources <- Filter(function(x) substring(x, 1, 5) != 'test/', project$find(''))
  resources <- gsub('^\\/', '', resources)
  all_routes <- names(project$cache_get("routes"))
  unrouted_resources <- Filter(
    function(x) !director:::any_is_substring_of(x, all_routes), resources)
  resources <- Filter(function(x) director:::any_is_substring_of(x, routes), resources)
  resources <- c(unrouted_resources, resources)

  # Remove system resources from consideration.
  built_in_routes <- c('config', 'etc', 'lib/controllers')
  exceptions <- c(built_in_routes, test_environment_config(project)$optional_tests)
  resources <- Filter(
    function(x) !director:::any_is_substring_of(x, exceptions), resources)

  # Error if any resources don't have tests.
  # TODO: (RK) Check for tests in subdirectories only?
  necessary_tests <- file.path('test', resources)
  missing_tests <- setdiff(necessary_tests, c(tests, ignore))
  if (length(missing_tests) > 0) {
    stop(call. = FALSE, "Tests are missing for the following resources:\n\n",
         crayon::red(paste(gsub('^test/', '', missing_tests), collapse = "\n")))
  }
}

#' Fetch the test setup or teardown hook, if any exists.
#'
#' The resource \code{config/environments/test} should contain a local variable
#' \code{setup} or \code{teardown} that has a function or list of functions to
#' be incorporated into a stageRunner that will run the actual test setup
#' or teardown.
#'
#' The seed environment for the stageRunner will contain the director object
#' of the relevant project in the key \code{director}.
#'
#' @param project director or character. The director for the syberia project.
#' @param type character. Must be \code{'setup'} or \code{'teardown'}, the former
#'   being the default.
#' @seealso \code{\link{test_project}}
#' @return a stageRunner that will run the relevant setup or teardown hook(s).
test_hook <- function(project, type = 'setup') {
  if (!is.director(project)) {
    stop("To fetch the ", type, " hook for a project, please pass in a director ",
         "object (the director for the syberia project). Instead I got ",
         "an object of class ", class(project)[1])
  }

  test_environment_path <- 'config/environments/test'
  if (project$exists(test_environment_path)) {
    # TODO: (RK) Fix director absolute file paths in $.filename and this hack
    filename <- director:::strip_root(project$root(),
                                      project$filename(test_environment_path))
    hooks <- test_environment_config(project)[[type]] %||% list(force)

    # TODO: (RK) Maybe replace this with a new stageRunner method to check 
    # argument validity? In the future, stageRunner could maybe do more!
    colored_filename <- sQuote(crayon::blue(filename))
    if (!is.list(hooks) && !is.function(hooks) && !is.stagerunner(hooks)) {
      stop("Test ", type, " hooks must be a function or a list of functions.\n\nIn ",
           colored_filename, ", ensure that ",
           "you have ", sQuote(crayon::yellow(paste0(type, ' <- some_function'))),
           " as right now it's an object of class ",
           sQuote(crayon::red(class(hooks)[1])), call. = FALSE)
    }
    if (!is.list(hooks)) hooks <- list(hooks)

    all_have_correct_arity <- is.stagerunner(hooks) || all(rapply(hooks, how = 'unlist',
      function(hook) is.function(hook) && length(formals(hook)) > 0))
    if (!all_have_correct_arity) {
      stop("Test ", type, " hooks must all be functions that take at least one ",
           "argument.\n\nThe first argument will be an environment that has one ",
           "key, ", sQuote('director'), ". In ", colored_filename,
           " ensure your ", sQuote(crayon::yellow(type)),
           " local variable meets this constraint.", call. = FALSE)
    }

    # Do not give access to global environment to ensure modularity.
    hook_env <- new.env(parent = parent.env(globalenv()))
    hook_env$director <- project

    stageRunner(hook_env, hooks)
  } else stageRunner(new.env(), list(force))
}

#' Get the configuration for the test environment.
#'
#' @param project director or character. The director for the syberia project.
test_environment_config <- function(project) {
  test_environment_path <- 'config/environments/test'
  if (!project$exists(test_environment_path)) list()
  else project$resource(test_environment_path)
}

</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>utils.r</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">`%||%`   <- function(x, y) if (is.null(x)) y else x
`%|||%`  <- function(x, y) if (is.falsy(x)) y else x
is.falsy <- function(x) {
  identical(x, NULL) || identical(x, FALSE) || identical(x, "") ||
  length(x) == 0 || identical(x, 0)
}

#' Fetch the current Syberia version.
#' @export
syberia_version <- function() { utils::packageVersion('syberia') }

package_exists <- function(name) {
  is.element(name, base::.packages())
}

as.list.environment <- function(env) {
  out <- base::as.list.environment(env)
  lapply(out, function(x) if (is.environment(x) && !is(x, "R6")) as.list(x) else x)
}

#' Ensure no global variables are polluted during an expression.
#'
#' If any global variables are removed or created, it will
#' give a descriptive error.
#' 
#' @param expr expression. The R expression to evaluate
#' @param desc character. A string to add to "you modified global 
#' @param check_options logical. Whether to check if any global options were changed.
#'   variables while [\code{desc} goes here]".
ensure_no_global_variable_pollution <- function(expr, desc, check_options = FALSE) {
  if (isTRUE(check_options)) old_options <- options()
  before <- ls(globalenv())

  out <- eval.parent(substitute(expr))

  after <- ls(globalenv())
  missing_desc <- missing(desc)
  shorten <- function(vars) if (length(vars) > 5) c(vars[1:5], '...') else vars
  message <- function(vars, type = 'variables', action = 'removed') {
    msg <- paste("Some global", type, "were", action)
    if (!eval.parent(quote(missing_desc))) msg <- paste(msg, "while", desc)
    msg <- paste0(msg, ": ", crayon::red(paste(vars, collapse = ", ")))
  }

  check_before_after <- function(before, after, type) {
    if (length(bads <- setdiff(before, after)) > 0) stop(message(bads, type = type))
    else if (length(bads <- setdiff(after, before)) > 0)
      stop(message(bads, type = type, action = 'added'))
  }

  check_before_after(before, after, 'variables')

  if (isTRUE(check_options) && !identical(new_options <- options(), old_options)) {
    before <- ls(old_options); after <- ls(new_options)
    check_before_after(before, after, 'options')
    diffs <- vapply(before,
      function(name)! identical(old_options[[name]], new_options[[name]]), logical(1))
    stop("Some global options were modified: ",
         crayon::red(paste(names(which(diffs)), collapse = ", ")))
  }

  out
}

#' Perform an action repeatedly on parent directories until success or error.
#' 
#' Given a \code{fn}, we may wish to run it on a \code{filepath}, determine
#' its success, and try again with the parent directory of \code{filepath},
#' until we obtain result that is not \code{NULL}. If this does not occur for
#' any parent directory, we halt with the string \code{error}.
#'
#' @param filepath character. The filepath to traverse along. The \code{fn}
#'    function will be called with \code{filepath} and its parent directories
#'    until it returns a result other than \code{NULL}.
#' @param fn function. A one-argument function called on \code{filepath} or
#'    its successive parent directories until a result other than \code{NULL}
#'    is returned, which will be the final return value.
#' @param error character or function. A string to error if \code{fn} returns
#'    \code{NULL} on all parent directories, or a one-argument function to
#'    execute (the argument received will be the initial \code{filepath})
#' @return The result of \code{fn} on the first parent directory of
#'   \code{filepath} on which it is not \code{NULL}.
traverse_parent_directories <- function(filepath, fn, error) {
  stopifnot(is.character(filepath), length(filepath) == 1, !is.na(filepath))
  stopifnot(is.function(fn), length(formals(fn)) >= 1)
  stopifnot(is.character(error) || is.function(error))

  path <- normalizePath(filepath)</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>As long as we have not hit the root directory, keep trying</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  while (!identical(dirname(path), path)) {
    result <- fn(path)
    if (!is.null(result)) return(result)
    path <- dirname(path)
  }

  if (is.character(error)) stop(error)
  else error(filepath)
}

order_by_key <- function(list) {
  list[order(names(list))]
}

is.simple_string <- function(obj) {
  is.character(obj) && length(obj) == 1 && !is.na(obj) && nzchar(obj)
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>zzz.r</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">.onAttach <- function(...) {
  if (!isTRUE(getOption("syberia.silent"))) {
    packageStartupMessage(paste0("Loading ", crayon::red("Syberia"), "...\n"))
  }
  
  # We want to initialize a Syberia project in the current working directory
  # because 9 times out of 10 this is what the user wants.
  #
  # However, this hook doesn"t work on install, because install is done from
  # the working directory of the package, not the user.
  #
  # But when the user calls library(syberia), this will work.
  try(syberia_project(), silent = TRUE)
}</span></code>
            </pre>
          </div>
        </div>
      <div class="section">
      </div>

    </div>
  </body>
</html>
